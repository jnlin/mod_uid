<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>mod_uid.c, version 1.0</title>
  </head>
  <body bgcolor="#ffffff">

    <h1 align=center >mod_uid.c version 1.0</h1>
    <center>модуль, выдающий "правильные" cookies для подсчета посетителей
      сайта <p></center>
    <h3>Оглавление</h3>
    <ol>
      <li><a href="#1">Copyright</a>
      <li><a href="#2">Назначение</a>
      <li><a href="#3">Установка (Apache 1.x)</a>
      <li><a href="#3a">Установка (Apache 2.0.x)</a>
      <li><a href="#4">Конфигурация</a>
      <li><a href="#format">Формат cookie</a>
      <li><a href="#5">Что можно записать в лог</a>
      <li><a href="#6">Почему не mod_usertrack</a>
      <li><a href="#7">TODO</a>
    </ol>
    <a name="1"></a>
    <h3>Copyright</h3>
    
    Copyright (C) 2000-2002 Alex Tutubalin, lexa@lexa.ru <p>
      
      Допускается распространение и использование в производных
      продуктах на условиях аналогичных 
	<a href="http://www.apache.org/LICENSE.txt">Apache License</a> 
      - должен быть сохранен копирайт автора и ссылка на 
      <a href="http://www.lexa.ru/lexa/">http://www.lexa.ru/lexa</a>,
      производный продукт не должен называться mod_uid<p>

      Прототип этого модуля был сделан автором при работе в компании 
      <a href="http://www.rambler.ru">Rambler</a>, данная версия cущественно
      переработана<p>

      Автор благодарит <b>Дмитрия Хрусталева</b> за ценные советы.<p>

      <a name="2"></a>
    <h3>Описание</h3>

Стандартные средства Apache не дают разумных средств трэкинга
пользователей (о проблемах mod_usertrack написано <a href="#6">ниже</a>), данный модуль 
их предоставляет.
<p>
Что он делает:
<ul>
 <li> если пользователь отдал заголовок Cookie с правильным cookie-name,
   то записывает эту Cookie в notes c именем uid_got (потом,
   соответственно, это можно записать в лог)
 <li> если пользователь пришел без нужной cookie - выдает ему заголовок
   SetCookie и записывает выданную cookie в notes с именем uid_set
   (и это можно тоже записать в лог)
 <li> если включена встроенная поддержка P3P, то при выдаче заголовка
   Set-Cookie выдается и заголовок P3P
</ul>
<p>
Достоинства:
<ul>
 <li>в cookie присутствует дата ее выдачи и "номер сервиса"
   (т.е. число, задаваемое при настройке), что позволяет понять когда
   пользователь пришел на наш сайт впервые и куда именно он пришел.
 <li> поддержана многосерверная работа - при аккуратной настройке (либо
   при полном ее отсутствии :) гарантируется, что выданная
   пользователю cookie будет уникальна
 <li> выданная пользователю и полученная от него cookie не смешиваются в
   лог-файле 
 <li> cookies имеют длину 128 бит, что позволяет для работы с ними в
   анализаторе логов (быстрый поиск и т.п.) использовать готовый код,
   предназначенный  для работы с IPv6 (например, libpatricia)
 <li> Поддержана P3P (в минимальном объеме)
</ul>

      <a name="3"></a>
<h3>Установка (Apache 1.x)</h3>
При конфигурации Apache к параметрам ./configure нужно добавить
    --add-module=/path/to/mod_uid.c:
<pre>
tar xzvf apache_1.3xxx
tar xzvf mod_uid-1.0.xx.tar.gz
cd apache_1.3xx
./configure --prefix=/usr/local/apache \
... --add-module=../mod_uid_1.0.xx/mod_uid.c other-params
make
make install
</pre>
      <a name="3a"></a>

<h3>Установка (Apache 2.0)</h3>
Для работы с Apache 2.0 предназначен модуль mod_uid2.c<br>
Сначала необходимо установить Apache 2.0.x, предположим, мы сделали
   это в директорию /usr/local/apache<br>
Для установки модуля mod_uid2 нужно использовать программу apxs:
<pre>
tar xzvf mod_uid-1.xx.tar.gz
cd mod_uid-1.xx
/usr/local/apach/bin/apxs -i -c -a mod_uid2.c
</pre>
эта команда скомпилирует модуль (ключ -c), установит его в каталог
    Apache (ключ -i) и активирует модуль добавлением команды
    LoadModule в httpd.conf (ключ -a)


      <a name="4"></a>

<h3>Конфигурационные директивы</h3>

  Все конфигурационные директивы можно указывать где угодно -
Server/VirtualServer/Location/... При указании в .htaccess должно быть 
разрешено AllowOverride FileInfo (или All)<p>

    <dl>
      <dt><b>UIDActive</b> On/Off</dt>
      <dd>  включить-выключить выдачу cookie.<br> Если выдача выключена, то
	полученные от клиента cookies все-равно раскодируются и могут
	быть записаны в log.<br>
	<i>Default:</i> On
      </dd>
      
      <dt><p></dt>
      <dt><b>UIDCookieName</b> string</dt>
      <dd>Имя cookie (<i>default</i> - uid)<br>
	Имя cookie, выдаваемой клиенту. Не должно пересекаться с
	какими-то другими именами, используемыми на сайте.
      </dd>
      <dt><p></dt>
      <dt><b>UIDService</b> number</dt>
      <dd> "Номер сервиса" - строго положительное (ненулевое)
	уникальное число, идентифицирующее данный  
	сервер в кластере, либо данный документ/набот документов.<br>
	Данный номер используется для двух целей:
	<ol>
	  <li>Если используется несколько серверов внутри одного
	    домена (с одинаковым параметром cookie domain=), либо с
	    одним hostname, то задание разных <b>UIDService</b>
	    приводит к тому, что выдаваемые разными серверами cookies
	    с гарантией будут уникальными.
	  <li>Использование разных <b>UIDService</b> для разных
	    разделов сервера позволяет при анализе логов выяснить, на
	    какой из разделов клиент пришел в первый раз.
	</ol>
	<i>Default:</i> IP-адрес сервера.
      </dd>
      <dt><p></dt>
      <dt><b>UIDDomain</b> .domain.name</dt>
      <dd> Имя домена для которого выдается кука<br>
	В многосерверных конфигурациях позволяет иметь общее
	пространство cookies для всех серверов (например, для
	mail.rambler.ru, www.rambler.ru, info.rambler.ru используется
	домен .rambler.ru)<br>
	Если нужно выключить domain= для какого-то набора документов,
	оставив его включенным для сервера в целом, в соответствующем
	разделе конфигурации (Location/Directory/...) нужно
	использовать <code>UIDDomain none</code><br>
	<i>Defaulut:</i> нет домена т.е. пользовательский браузер
	будет возвращать cookie только на исходный сервер.
      </dd>
      <dt><p></dt>
      <dt><b>UIDPath</b>  string</dt>
      <dd>Путь для которого выдается cookie (параметр path= в
	Set-Cookie:)<br>
	<i>Default:</i> /
	</dd>
      <dt><p></dt>
      <dt><b>UIDExpires</b> number<br>
	<b>UIDExpires</b> plus 3 year 4 month 2 day 1 hour 15 minutes
	</dt>
      <dd>
      Задание Expiration date для cookie.<br>
      <code>UIDExpires number</code>  - прибавить number секунд к
      текущему времени
      <code>UIDExpires plus 3 year 4 month 2 day 1 hour 15
	minutes</code> - то же самое, но выраженное по человечески.
      <br>
      <i>Default:</i> прибавляется 10 лет к текущей дате
      </dd>
      <dt><p></dt>
      <dt><b>UIDP3P</b> On/Off/Always</dt>
      <dd>Управление выдачей заголовка P3P одновременно с выдачей
	cookie.<br>
	Варианты:
	<ul>
            <li>  Off - не выдавать заголовок P3P
             <li> On - выдавать только если у Cookie выдается параметр 
	    domain
	  <li>  Always - выдавать всегда (т.е. даже без domain)
	</ul>
	<i>Default:</i> Off<br>
	Эта директива нужна для удовлетворения ME IE6+ в
	многосерверной конфигурации и, например, включения кода
	"счетчика" с другого сервера на страницу. В случае, когда
	cookie выдается без domain= или domain "покрывает" текущее имя 
	сервера для основного документа MS IE6+ с настройками
	по-умолчанию удовлетворится и так, однако для составных
	документов, собранных с разных серверов, cookie могут
	подавляться.<br>
	<b>mod_uid</b> выдает только заголовок P3P (по-умолчанию -
	только с compact policy), поддержка /w3c/p3p.xml и подобного
	остается задачей владельца сервера.<br>
	Заголовок P3P выдается только если mod_uid выдает  заголовок
	Set-Cookie, т.е. если у вас выдаются и другие cookie и для них 
	тоже нужен P3P, то задачу выдачи P3P нужно решать отдельно и
	самостоятельно. 
	</dd>
      <dt><p></dt>
      <dt><b>UIDP3PString</b> string</dt>
      <dd>Текст заголовка P3P, выдаваемый клиенту.<br>
	<i>Default:</i> CP="NOI PSA OUR BUS UNI"
	</dd>
</dl>

      <a name="format"></a>

<h3>Формат Cookie</h3>

    Формат куки:
   В двоичном виде:
   unsigned int cookie[4], где<br>
<ul>
   cookie[0] - "номер сервиса" (задается через UIDService)<br>
   cookie[1] - время выдачи (unix time)<br>
   cookie[2] - pid процесса выдавшего куку<br>
   cookie[3] - старшие 24 бита - уникальный секвенсер
               в пределах процесса (стартовое значение -
	0x030303),<br> 
	младшие 8 бит - номер версии куки (сейчас - 2)<br> 
</ul>
Эти 128 бит переводятся в network byte order, кодируются в base64 и
    отдаются клиенту (в версии 1 все отдавалось в host order, что
    затрудняло поддержку кластеров серверов с разной
    архитектурой).<br>
<h4>Уникальность</h4>
Очевидно, что полную гарантию может дать только страховой полис и если 
    в пределах одного домена будет выдано более чем 2^128 cookies, то
    какие-то из них будут повторяться. Однако при разработке формата cookie
    были приложены усиля к тому, чтобы при разумном количестве cookies 
    они были бы уникальными.
<ol>
<li>В случае, если  "номера сервиса" уникален (свой у каждого сервера) 
	в пределах данного домена, разные серверы будут с гарантией
	выдавать разные cookies.
<li> Включение в cookie времени выдачи и pid подразумевает, что pid-ы
	разных процессов не повторяются в течение одной секунды. На
	всех известных мне Unix-системах это так - pid-ы монотонно
	возрастают до некоего максимума - 2^16 или более - т.е. для
	повторения cookie[1]/cookie[2] в рамках одного сервера нужно
	делать больше чем 2^16 fork() в секунду, что на сегодняшний
	день малореально.
<li> Секвенсер (старшие 24 бита в cookie[3]) позволяет удостовериться
	в уникальности cookie в пределах одного процесса в течение
	одной секунды. Разрядность секвенсера позволяет выдавать до
	1.0E+07 cookies одним процессом в секунду.
</ol>
      <a name="5"></a>

<h3>Что можно записать в лог</h3>

<b>mod_uid</b> пишет в notes ("заметки") одно из двух значений:
<ol>
<li>Если от клиента была получена cookie, она помещается в note
	"uid_got"
<li>Если клиенту была выдана cookie, она помещается в note "uid_set"
</ol>
Cookies пишутся в лог как 4 32-битных 16-ричных числа в host-order
    (т.е. для версии 2 производится преобразование network-host, для
    версии 1 - все пишется как есть в предположении, что архитектура
    сервера с момента выдачи cookie не изменилась)


В <b>LogFormat</b> эти notes можно использовать в виде \"%{uid_got}n\" 
    и \"%{uid_set}n\" соответственно.<br>
При использовании LogFormat такого вида:
<pre>
LogFormat "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\" \"%{uid_got}n\" \"%{uid_set}n  combined_cookie
</pre>
мы получим примерно такие записи в log-е
<pre>
Выданная клиенту Cookie:
62.104.212.93 - - [05/Jan/2002:00:02:06 +0300] "GET / HTTP/1.0" 200
13487 "-" "Mozilla/4.0 (compatible; MSIE 5.5; Windows 98; Win 9x
4.90)" "-" "ruid=000000013C36184E00009A2100002901" 

Полученная от клиента Cookie:
216.136.145.172 - - [05/Jan/2002:00:14:59 +0300] "GET /buttons/but-support-e.gif
 HTTP/1.0" 200 252 "http://apache.lexa.ru/english/meta-http-eng.html" 
"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)" 
"ruid=000000013C361B5000009A0100009501" "-" 
</pre>
Такой формат без проблем понимается распространенными анализаторами
    логов, включая Webtrends, который по такому логу с удовольствием
    считает Visitors.


      <a name="6"></a>
<h3> Почему не mod_usertrack из поставки Apache</h3>

 Потому что у него есть несколько недостатков:
<ul>
 <li> нет гарантий, что двум пользователям не будет выдана одинаковая
    cookie, хотя конечно включение getpid(), remote_ip и времени до
    миллисекунд сводит эту вероятность к минимуму
 <li> нет поддержки многосерверной работы - а в этом случае возможность
    выдачи  одинаковой cookie возрастает
 <li> в логе хочется иметь возможность видеть и выданную пользователю
    cookie, причем видеть ее отдельно, mod_usertrack их перемешивает.
 <li> Хочется иметь "номер сервиса" (см. выше) - чтобы понимать на какой 
   из наших сервисов пользователь зашел при первом своем визите.
</ul>

      <a name="7"></a>
<h3>TODO</h3>
<ol>
<li>
 Поддержка разных форматов (Netscape/Cookie/Cookie2 - как в
 mod_usertrack), но только если появится реальная необходимость - пока 
 таковой необходимости не замечено.
<li> Есть смутное подозрение, что на multithread-apache и
	многопроцессорных машине инкремент sequencer-а нужно обложить mutex-ами
</ol>


<!-- $Id: README-rus.html,v 1.2 2002/04/20 16:56:19 lexa Exp $ --> 
</body>
</html>
